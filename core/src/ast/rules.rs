//! file: core/src/ast/rules.rs
//! description: Helpers for working with the `pest` parser and converting its
//! types into the project's AST and error reporting types.
//!
//! This module defines the `RulesParser` type generated by `pest_derive` and
//! provides helper functions to extract `Location` and `Span` information from
//! `pest` parser `Pair`/`Pairs`. It also includes utility functions to fetch
//! the next pair from a `Pairs` iterator while attaching appropriate error
//! metadata (`SyntaxError` wrapped as `MainstageErrorExt`).
//!
//! The docs below include usage notes, error semantics, lifetime guidance, and
//! a small example to help integrate these helpers into the AST parsing flow.
//!
//! See also: `grammar.pest` (top-level rule: `Rule::script`),
//! `crate::script::Script`, `crate::ast::err::SyntaxError`.
//!
//! authors: Colton McGraw <github.com/ColtMcG0>
//! created: 2025-11-23
//! updated: 2025-12-03
//! license: LICENSE.md
//!
//! # Usage notes
//!
//! - The `RulesParser::parse(Rule::script, &script.content)` entrypoint produces
//!   `Pairs<'_, Rule>` which the helpers in this module convert into inner
//!   iterators along with `Location`/`Span` suitable for error reporting.
//! - Line/column coordinates are 1-based (as returned by `pest`). `get_location_*`
//!   use start positions for `Location` and both start/end positions for `Span`.
//! - `Pairs` and `Pair` types borrow from the input string. Callers must keep
//!   the original `Script.content` alive while holding `Pairs` references.
//!
//! # Error semantics
//!
//! - `fetch_next_pair` will return a `SyntaxError` (wrapped in
//!   `Box<dyn MainstageErrorExt>`) when the iterator is exhausted. The error
//!   includes the optional `location` and `span` passed by the caller to help
//!   locate the problem in source.
//! - Error `issuer` strings follow the pattern `mainstage.ast.rules.<fn>` so
//!   tooling can categorize or filter diagnostics.
//!
//! # Thread-safety & performance
//!
//! - These helpers are simple, allocation-light adapters: they clone `Pair`
//!   iterators and create small `Location`/`Span` structs. They are suitable
//!   for parser-time use but should be avoided in hot loops.
//! - The helpers themselves are thread-safe (no global state) but `Pairs` live
//!   by reference into the original `Script` content, so callers must coordinate
//!   lifetimes when sharing across threads.
//!
//! # Example
//!
//! A compact, illustrative example (marked `ignore` to avoid invoking doctest
//! compilation/execution in CI). This shows the intended flow; adapt to your test helpers
//! or harness when making runnable examples.
//!
//! ```ignore
//! use mainstage_core::ast::{RulesParser, Rule};
//! use mainstage_core::script::Script;
//!
//! // Construct a Script; tests may provide a helper to do this from a string.
//! let s = Script { name: "example.ms".into(), path: std::path::PathBuf::from("."), content: "workspace {}".into() };
//! // Parse and get the first top-level pair
//! let pairs = RulesParser::parse(Rule::script, &s.content).unwrap();
//! let first = pairs.into_iter().next().unwrap();
//! // Use helpers in this module to obtain location/span for the pair
//! let loc = mainstage_core::ast::rules::get_location_from_pair(&first, &s);
//! ```
//!
//! # Doctest guidance
//!
//! - When adding doctest examples here prefer `no_run` or self-contained code
//!   that constructs a `Script` and calls `RulesParser::parse`. Avoid `?` in
//!   doctests unless you wrap the example in a `fn main() -> Result<_,_>` body.
//!

use pest_derive::Parser;

use crate::location;

/// Parser for the Mainstage grammar generated by `pest`.
///
/// The `RulesParser` type is generated from `grammar.pest` via the
/// `pest_derive::Parser` macro. It exposes the `parse` entrypoint used by the
/// AST helpers in this module. This module contains small helpers that adapt
/// `pest`'s `Pair`/`Pairs` types into the project's `Location`/`Span` types and
/// produce `MainstageErrorExt` errors when grammar expectations are violated.
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct RulesParser;

/// Advance a `Pairs` iterator and return the next `Pair`.
///
/// This helper centralizes error construction when an iterator is unexpectedly
/// exhausted. It attaches the provided `location` and `span` to the produced
/// `SyntaxError` so callers can report precise source locations.
///
/// # Arguments
///
/// - `pairs`: Mutable reference to a `pest::iterators::Pairs<'a, Rule>` iterator.
/// - `location`: Optional `Location` to attach to an error if the iterator is
///   empty.
/// - `span`: Optional `Span` to attach to an error if the iterator is empty.
///
/// # Returns
///
/// - `Ok(Pair)` containing the next inner pair when present.
/// - `Err(Box<dyn MainstageErrorExt>)` with a `SyntaxError` if the iterator is
///   empty.
pub(crate) fn fetch_next_pair<'a>(
    pairs: &mut pest::iterators::Pairs<'a, Rule>,
    location: &Option<location::Location>,
    span: &Option<location::Span>,
) -> Result<pest::iterators::Pair<'a, Rule>, Box<dyn crate::ast::MainstageErrorExt>> {
    match pairs.next() {
        Some(pair) => Ok(pair),
        None => Err(Box::<dyn crate::ast::MainstageErrorExt>::from(Box::new(
            crate::ast::err::SyntaxError::with(
                crate::Level::Error,
                "Expected more inner pairs but found none.".into(),
                "mainstage.ast.rules.get_next_inner_pair".into(),
                location.clone(),
                span.clone(),
            ),
        ))),
    }
}

/// Return the inner `Pairs` of `rule` together with `Location` and `Span`.
///
/// Many AST parsing helpers need the rule's inner iterator and the source
/// position information. This function clones the pair's inner rules and uses
/// the `get_location_from_pair` / `get_span_from_pair` helpers to produce the
/// diagnostics metadata.
///
/// # Arguments
///
/// - `rule`: Reference to a `pest::iterators::Pair<Rule>` to extract data from.
/// - `script`: Reference to the `Script` containing the source for location info.
///
/// # Returns
///
/// - Tuple containing:
///   - `Pairs<'a, Rule>`: The inner rules of the provided pair.
///   - `Option<Location>`: The location of the start of the pair.
///   - `Option<Span>`: The span covering the pair.
///
pub(crate) fn get_data_from_rule<'a>(
    rule: &pest::iterators::Pair<'a, Rule>,
    script: &crate::script::Script,
) -> (
    pest::iterators::Pairs<'a, Rule>,
    Option<crate::location::Location>,
    Option<crate::location::Span>,
) {
    let inner_rules = rule.clone().into_inner();
    let span = get_span_from_pair(&rule, script);
    let location = get_location_from_pair(&rule, script);
    (inner_rules, location, span)
}

/// Convert a `pest::Pair` into an optional `Location` for error reporting.
///
/// The returned `Location` contains the source file name (from `script`) and
/// the 1-based line and column of the pair's start position. This helper
/// always returns `Some(Location)` because `pest::Pair::as_span()` provides
/// concrete positions; callers may still wrap or drop the result as needed.
///
/// # Arguments
///
/// - `rule`: Reference to a `pest::iterators::Pair<Rule>` to extract data from.
/// - `script`: Reference to the `Script` containing the source for location info.
///
/// # Returns
///
/// - `Option<Location>`: The location of the start of the pair.
///
pub fn get_location_from_pair(
    rule: &pest::iterators::Pair<Rule>,
    script: &crate::script::Script,
) -> Option<crate::location::Location> {
    let span = rule.as_span();
    Some(crate::location::Location {
        file: script.name.clone(),
        line: span.start_pos().line_col().0,
        column: span.start_pos().line_col().1,
    })
}

/// Convert a `pest::Pair` into a `Span` covering the pair's start and end
/// locations.
///
/// The returned `Span` contains `Location` values for both the start and end
/// of the pair. Line/column coordinates are derived from `pest`'s
/// `start_pos().line_col()` and `end_pos().line_col()` helpers.
///
/// # Arguments
///
/// - `rule`: Reference to a `pest::iterators::Pair<Rule>` to extract data from.
/// - `script`: Reference to the `Script` containing the source for location info.
///
/// # Returns
///
/// - `Option<Span>`: The span covering the pair.
///
pub fn get_span_from_pair(
    rule: &pest::iterators::Pair<Rule>,
    script: &crate::script::Script,
) -> Option<crate::location::Span> {
    let span = rule.as_span();
    Some(crate::location::Span {
        start: crate::location::Location {
            file: script.name.clone(),
            line: span.start_pos().line_col().0,
            column: span.start_pos().line_col().1,
        },
        end: crate::location::Location {
            file: script.name.clone(),
            line: span.end_pos().line_col().0,
            column: span.end_pos().line_col().1,
        },
    })
}
