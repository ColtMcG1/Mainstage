//! file: core/src/ast/mod.rs
//! description: AST module root and parsing entrypoints.
//!
//! Re-exports AST node types and provides helpers to generate `Pairs`
//! from a `Script` and to convert the top-level parse into an `AstNode`
//! representing the entire script.
//!
pub mod err;
pub mod expr;
pub mod kind;
pub mod node;
pub mod rules;
pub mod stmt;

/// Re-exporting for easier access
pub use err::*;
pub use kind::{AstNodeKind, BinaryOperator, UnaryOperator};
pub use node::AstNode;
pub use rules::RulesParser;

use crate::ast::rules::Rule;
use crate::{Level, Location, MainstageErrorExt, Script, Span};

use pest::Parser;
use stmt::*; // Import the Parser trait // Import the Rule enum generated by pest

pub fn generate_rules_from_script(
    script: &Script,
) -> Result<pest::iterators::Pairs<'_, Rule>, Box<dyn MainstageErrorExt>> {
    RulesParser::parse(Rule::script, &script.content).map_err(|e| {
        // Extract line/column from the pest error and construct Location/Span
        // Access the `line_col` field which holds numeric positions. It may be
        // a `Pos((line,col))` or a `Span((start_line,start_col),(end_line,end_col))`.
        let (line, col) = match e.line_col {
            pest::error::LineColLocation::Pos((l, c)) => (l, c),
            pest::error::LineColLocation::Span((sl, sc), _end) => (sl, sc),
        };
        let loc = Location::new(script.name.clone(), line, col);
        let span = Span::new(loc.clone(), loc.clone());
        Box::<dyn MainstageErrorExt>::from(Box::new(err::SyntaxError::with(
            Level::Error,
            "There was a syntax error in the script.".into(),
            "mainstage.ast.generate_rules_from_script".into(),
            Some(loc),
            Some(span),
        )))
    })
}

pub fn generate_ast_from_source(script: &Script) -> Result<AstNode, Box<dyn MainstageErrorExt>> {
    // Placeholder implementation
    if script.is_empty() {
        Err(Box::new(err::EmptyScriptError::with(
            Level::Error,
            "The provided script is empty.".into(),
            "mainstage.ast.generate_ast_from_source".into(),
            None,
            None,
        )))
    } else {
        // Use the centralized parser helper so parse errors carry location/span info
        let rules = generate_rules_from_script(script)?;

        let first_rule = rules.into_iter().next().unwrap();

        let span = rules::get_span_from_pair(&first_rule, script);
        let location = rules::get_location_from_pair(&first_rule, script);

        if first_rule.as_rule() == Rule::script {
            let body = first_rule
                .into_inner()
                .map(|f| parse_item_rule(f, script))
                .collect::<Result<Vec<AstNode>, Box<dyn MainstageErrorExt>>>()?;
            Ok(AstNode::new(AstNodeKind::Script { body }, location, span))
        } else {
            let err = err::SyntaxError::with(
                Level::Error,
                "The top-level rule is not a script rule.".into(),
                "mainstage.ast.generate_ast_from_source".into(),
                location,
                span,
            );
            Err(Box::<dyn MainstageErrorExt>::from(Box::new(err)))
        }
    }
}
