pub mod err;
pub mod kind;
pub mod node;
pub mod rules;
pub mod stmt;
pub mod expr;

/// Re-exporting for easier access
pub use err::*;
pub use kind::{AstNodeKind, BinaryOperator, UnaryOperator};
pub use node::AstNode;
pub use rules::RulesParser;

use crate::ast::rules::Rule;
use crate::{Level, MainstageErrorExt, Script};

use pest::Parser;
use stmt::*; // Import the Parser trait // Import the Rule enum generated by pest

pub fn generate_rules_from_script(
    script: &Script
) -> Result<pest::iterators::Pairs<'_, Rule>, Box<dyn MainstageErrorExt>> {
    RulesParser::parse(Rule::script, &script.content).map_err(|_| {
        Box::<dyn MainstageErrorExt>::from(Box::new(err::SyntaxError::with(
            Level::Error,
            "There was a syntax error in the script.".into(),
            "mainstage.ast.generate_rules_from_script".into(),
            None,
            None,
        )))
    })
}

pub fn generate_ast_from_source(script: &Script) -> Result<AstNode, Box<dyn MainstageErrorExt>> {
    // Placeholder implementation
    if script.is_empty() {
        Err(Box::new(err::EmptyScriptError::with(
            Level::Error,
            "The provided script is empty.".into(),
            "mainstage.ast.generate_ast_from_source".into(),
            None,
            None,
        )))
    } else {
        let rules = RulesParser::parse(Rule::script, &script.content).map_err(|_| {
            Box::<dyn MainstageErrorExt>::from(Box::new(err::SyntaxError::with(
                Level::Error,
                "There was a syntax error in the script.".into(),
                "mainstage.ast.generate_ast_from_source".into(),
                None,
                None,
            )))
        })?;

        let first_rule = rules.into_iter().next().unwrap();

        let span = rules::get_span_from_pair(&first_rule, script);
        let location = rules::get_location_from_pair(&first_rule, script);

        if first_rule.as_rule() == Rule::script {
            let body = first_rule
                .into_inner()
                .map(|f| parse_item_rule(f, script))
                .collect::<Result<Vec<AstNode>, Box<dyn MainstageErrorExt>>>()?;
            Ok(AstNode::new(AstNodeKind::Script { body }, location, span))
        } else {
            let err = err::SyntaxError::with(
                Level::Error,
                "The top-level rule is not a script rule.".into(),
                "mainstage.ast.generate_ast_from_source".into(),
                location,
                span,
            );
            Err(Box::<dyn MainstageErrorExt>::from(Box::new(err)))
        }
    }
}
